# Task ID: 9
# Title: Implement String Parsing System
# Status: done
# Dependencies: 3, 4, 5
# Priority: medium
# Description: Create parser for converting strings like '10.5 kg' into measurement objects
# Details:
Create src/unit/parser.cr:
```crystal
module Unit
  module Parser
    FRACTION_REGEX = /^(\d+)\s*\/\s*(\d+)$/
    DECIMAL_REGEX = /^(-?\d+\.?\d*)$/
    MEASUREMENT_REGEX = /^\s*(-?\d+\.?\d*|\d+\s*\/\s*\d+)\s+(.+?)\s*$/
    
    def self.parse(T : Class, input : String) : T
      match = MEASUREMENT_REGEX.match(input.strip)
      raise ArgumentError.new("Invalid format: #{input}") unless match
      
      value_str = match[1]
      unit_str = match[2].downcase
      
      # Parse value (handle fractions)
      value = if fraction_match = FRACTION_REGEX.match(value_str)
        BigRational.new(fraction_match[1].to_i, fraction_match[2].to_i)
      else
        BigDecimal.new(value_str)
      end
      
      # Parse unit
      unit = parse_unit(T, unit_str)
      T.new(value, unit)
    end
    
    private def self.parse_unit(T : Class, unit_str : String)
      # Match against unit names and aliases
      T::Unit.each do |unit|
        return unit if unit.to_s.downcase == unit_str
      end
      raise ArgumentError.new("Unknown unit: #{unit_str}")
    end
  end
end
```
- Support decimal and fractional notation
- Handle various spacing patterns
- Case-insensitive unit matching
- Clear error messages for invalid input

# Test Strategy:
Test parsing various formats: '10 kg', '10.5 pounds', '1/2 lb', '3.14159m', test error handling for invalid formats, test whitespace handling, verify fraction precision

# Subtasks:
## 1. Create Parser Module Structure and Basic Regex Patterns [done]
### Dependencies: None
### Description: Set up the Unit::Parser module with regex patterns for fractions, decimals, and measurements
### Details:
Create src/unit/parser.cr file and implement the Unit::Parser module with three core regex patterns: FRACTION_REGEX for matching fraction notation (e.g., '1/2'), DECIMAL_REGEX for matching decimal numbers including negative values, and MEASUREMENT_REGEX for matching the complete measurement string format. Ensure the MEASUREMENT_REGEX can handle both decimal and fraction values followed by unit strings with flexible whitespace.

## 2. Implement Value Parsing Logic with Fraction Support [done]
### Dependencies: 9.1
### Description: Parse numeric values from strings, handling both decimal and fraction formats with BigDecimal/BigRational
### Details:
Within the parse method, implement the value parsing logic that extracts the numeric portion from the regex match. Check if the value matches the fraction pattern first - if so, parse numerator and denominator and create a BigRational. Otherwise, parse as BigDecimal for decimal values. Ensure proper handling of negative values in both formats.

## 3. Implement Unit String Parsing and Matching [done]
### Dependencies: 9.1
### Description: Create the parse_unit method to match unit strings against enum values with case-insensitive comparison
### Details:
Implement the private parse_unit method that takes a measurement type class T and a unit string. Convert the unit string to lowercase for case-insensitive matching. Iterate through T::Unit enum values and compare each unit's string representation (converted to lowercase) with the input. Return the matching unit enum value when found. This should work generically for any measurement type (Weight, Length, etc.).

## 4. Complete Main Parse Method with Error Handling [done]
### Dependencies: 9.2, 9.3
### Description: Integrate value and unit parsing with proper error handling and validation
### Details:
Complete the main parse method that accepts a measurement type T and input string. Strip whitespace from input, apply MEASUREMENT_REGEX to extract value and unit parts. Call the value parsing logic to get BigDecimal or BigRational, then call parse_unit to get the unit enum. Create and return a new instance of T with the parsed value and unit. Include proper error handling with clear messages for invalid format (regex doesn't match) and unknown units.

## 5. Add Support for Unit Aliases and Edge Cases [done]
### Dependencies: 9.3, 9.4
### Description: Enhance parser to handle unit aliases and various spacing/formatting edge cases
### Details:
Extend the parse_unit method to also check against unit aliases (e.g., 'g' for Gram, 'lb' for Pound). Handle edge cases like multiple spaces between value and unit, leading/trailing whitespace, and units with special characters. Consider adding support for plural forms (e.g., 'pounds' vs 'pound'). Ensure the parser remains performant even with these additional checks.

