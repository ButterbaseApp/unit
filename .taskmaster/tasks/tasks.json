{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize Crystal Project Structure",
        "description": "Set up the Crystal project with shard.yml, directory structure, and development dependencies",
        "details": "Create a new Crystal shard with the following structure:\n- Initialize with `crystal init lib unit`\n- Configure shard.yml with name: unit, version: 0.1.0, crystal: \"~> 1.14\"\n- Add development dependencies: ameba (^1.6.1) for linting, crystal-coverage for test coverage\n- Set up GitHub Actions workflow for CI/CD with Crystal 1.14.0\n- Create .editorconfig with Crystal conventions (2 spaces, LF line endings)\n- Add .gitignore for Crystal projects including /lib/, /bin/, /.shards/\n- Create initial src/unit.cr entry point file\n- Set up spec/spec_helper.cr with require \"spec\" and require \"../src/unit\"",
        "testStrategy": "Verify project structure with: crystal spec --error-on-warnings, shards install completes successfully, ameba runs without errors, crystal build src/unit.cr produces no compilation errors",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Crystal project with crystal init",
            "description": "Create the base Crystal library structure using the crystal init command",
            "dependencies": [],
            "details": "Execute `crystal init lib unit` to create the initial project structure. This will generate the basic directory layout including src/, spec/, and initial files like README.md and shard.yml. Verify that the generated structure includes src/unit.cr as the main entry point and spec/unit_spec.cr for tests.",
            "status": "done",
            "testStrategy": "Verify that all expected directories and files are created: src/, spec/, shard.yml, README.md. Check that src/unit.cr contains the basic module definition and spec/spec_helper.cr is properly configured."
          },
          {
            "id": 2,
            "title": "Configure shard.yml with project metadata and dependencies",
            "description": "Set up shard.yml with correct project information and add development dependencies",
            "dependencies": [
              "1.1"
            ],
            "details": "Update the generated shard.yml file to include: name: unit, version: 0.1.0, crystal: \"~> 1.14\". Add development dependencies section with ameba (^1.6.1) for code linting and crystal-coverage for test coverage reporting. Ensure proper YAML formatting and indentation throughout the file.",
            "status": "done",
            "testStrategy": "Run `shards install` to verify all dependencies install correctly. Check that .shards directory is created with ameba and crystal-coverage dependencies. Run `shards check` to ensure dependency resolution works."
          },
          {
            "id": 3,
            "title": "Create GitHub Actions CI/CD workflow",
            "description": "Set up continuous integration with GitHub Actions for automated testing and linting",
            "dependencies": [
              "1.1"
            ],
            "details": "Create .github/workflows/ci.yml file with a workflow that: uses Crystal 1.14.0, runs on Ubuntu latest, executes `shards install`, runs `crystal spec --error-on-warnings`, runs `crystal tool format --check`, and executes ameba for linting. Include caching for shards dependencies to speed up builds.",
            "status": "done",
            "testStrategy": "Validate YAML syntax of the workflow file. Test locally by running all commands that the CI will execute: shards install, crystal spec --error-on-warnings, crystal tool format --check, and bin/ameba."
          },
          {
            "id": 4,
            "title": "Configure development environment files",
            "description": "Create .editorconfig and .gitignore files with Crystal-specific settings",
            "dependencies": [
              "1.1"
            ],
            "details": "Create .editorconfig with Crystal conventions: indent_style = space, indent_size = 2, end_of_line = lf, charset = utf-8, trim_trailing_whitespace = true, insert_final_newline = true. Set up .gitignore to exclude: /lib/, /bin/, /.shards/, *.dwarf, and other Crystal build artifacts. Also ignore coverage reports and temporary files.",
            "status": "done",
            "testStrategy": "Verify .editorconfig works in common editors by checking indentation. Test .gitignore by running shards install and ensuring /lib/ and /.shards/ directories are not tracked by git status."
          },
          {
            "id": 5,
            "title": "Set up initial source files and test helpers",
            "description": "Create the main entry point and configure the test spec helper",
            "dependencies": [
              "1.1",
              "1.2"
            ],
            "details": "Ensure src/unit.cr exists with proper module definition: `module Unit; VERSION = \"0.1.0\"; end`. Update spec/spec_helper.cr to include `require \"spec\"` and `require \"../src/unit\"`. Add any additional test configuration needed for crystal-coverage integration. Create a basic smoke test in spec/unit_spec.cr to verify the module loads correctly.",
            "status": "done",
            "testStrategy": "Run `crystal build src/unit.cr` to verify compilation without errors. Execute `crystal spec` to ensure tests run and the basic smoke test passes. Verify crystal-coverage can generate reports when tests are run."
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement Generic Measurement Class with Phantom Types",
        "description": "Create the core Measurement(T, U) class using phantom types for compile-time type safety",
        "details": "Implement src/unit/measurement.cr with:\n```crystal\nmodule Unit\n  class Measurement(T, U)\n    getter value : BigDecimal\n    getter unit : U\n    \n    def initialize(@value : Number, @unit : U)\n      @value = BigDecimal.new(@value.to_s)\n      validate_value!\n    end\n    \n    private def validate_value!\n      raise ArgumentError.new(\"Value cannot be nil\") if @value.nil?\n    end\n  end\nend\n```\n- Use BigDecimal for all internal storage to maintain precision\n- T represents the measurement type (Weight, Length, etc.)\n- U represents the unit enum type\n- Make the class immutable with readonly getters\n- Support Int32, Int64, Float32, Float64, BigDecimal, BigRational as input types",
        "testStrategy": "Test with various numeric types, verify immutability, test nil/invalid value rejection, verify BigDecimal conversion accuracy, test phantom type compile-time safety by attempting invalid type combinations",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Basic Measurement Class Structure",
            "description": "Set up the initial Measurement(T, U) class with phantom types and BigDecimal storage",
            "dependencies": [],
            "details": "Create src/unit/measurement.cr with the basic class structure including:\n- Module Unit namespace\n- Generic Measurement(T, U) class with phantom types\n- BigDecimal getter for value\n- Generic U getter for unit\n- Store T phantom type for compile-time type safety\n- Ensure immutability with readonly getters\n<info added on 2025-08-01T05:17:57.533Z>\nImplementation successfully completed with comprehensive testing suite. All core functionality working correctly including phantom type safety, BigDecimal precision storage, immutability design, and full test coverage. Ready to proceed with next subtask for flexible number input constructor.\n</info added on 2025-08-01T05:17:57.533Z>",
            "status": "done",
            "testStrategy": "Create spec/unit/measurement_spec.cr to verify class instantiation, phantom type parameters work correctly, getters return expected values"
          },
          {
            "id": 2,
            "title": "Implement Flexible Number Input Constructor",
            "description": "Add constructor that accepts various numeric types and converts to BigDecimal",
            "dependencies": [
              "2.1"
            ],
            "details": "Implement initialize method that:\n- Accepts Number union type (Int32, Int64, Float32, Float64, BigDecimal, BigRational)\n- Converts any input number to BigDecimal using to_s method for precision\n- Stores the unit parameter\n- Ensures type safety with proper type restrictions\n- Handle edge cases like infinity or NaN for float inputs\n<info added on 2025-08-01T05:57:58.404Z>\nImplementation completed successfully with comprehensive testing and error handling. Enhanced initialize method now handles all Number union types with proper BigDecimal conversion and edge case validation. Added 10 new test cases covering numeric type handling, precision preservation, and BigRational conversion accuracy. All 16 tests passing with zero failures or errors.\n</info added on 2025-08-01T05:57:58.404Z>",
            "status": "done",
            "testStrategy": "Test constructor with each numeric type, verify BigDecimal conversion accuracy, test precision preservation for large/small numbers, verify float edge cases are handled"
          },
          {
            "id": 3,
            "title": "Add Value Validation Logic",
            "description": "Implement validation to ensure measurement values are valid",
            "dependencies": [
              "2.2"
            ],
            "details": "Add validate_value! private method that:\n- Checks if value is nil (though Crystal's type system should prevent this)\n- Validates numeric bounds if needed\n- Raises ArgumentError with descriptive messages for invalid values\n- Consider adding checks for NaN or Infinity when constructed from floats\n- Ensure validation is called in constructor\n<info added on 2025-08-01T06:01:31.904Z>\nImplementation completed successfully with comprehensive value validation system including enhanced validate_value! method with edge case validation, BigDecimal conversion verification, empty string detection, and flexible validation architecture. Added 6 thorough validation tests covering normal/zero/negative values, boundary conditions, and construction-time validation. All 22 tests passing with robust error handling and descriptive ArgumentError messages. Validation integrated into all constructor paths ensuring data integrity at creation time. Foundation established for future domain-specific validation rules while leveraging Crystal's type system for additional safety.\n</info added on 2025-08-01T06:01:31.904Z>",
            "status": "done",
            "testStrategy": "Test validation with nil attempts, verify proper error messages, test boundary conditions, ensure validation runs during construction"
          },
          {
            "id": 4,
            "title": "Add Type Safety Compile-Time Tests",
            "description": "Create comprehensive tests to verify phantom type safety at compile time",
            "dependencies": [
              "2.3"
            ],
            "details": "Create compile-time tests that verify:\n- Measurement(Weight, WeightUnit) and Measurement(Length, LengthUnit) are distinct types\n- Cannot assign measurements of different phantom types to each other\n- Type parameters are properly enforced\n- Create example phantom type markers (empty modules/structs) for testing\n- Document how phantom types provide compile-time safety\n<info added on 2025-08-01T06:05:18.111Z>\nUPDATED: Implementation completed successfully with comprehensive type safety testing framework established. Created spec/unit/phantom_type_safety_examples.cr containing 5 distinct test cases that demonstrate compile-time phantom type enforcement. Tests verify that Measurement(Weight, WeightUnit) and Measurement(Length, LengthUnit) remain distinct types even when using identical unit enums, preventing improper assignment and ensuring type parameter integrity. All 27 existing tests continue to pass, confirming that phantom type safety implementation maintains backward compatibility while adding robust compile-time type checking capabilities.\n</info added on 2025-08-01T06:05:18.111Z>",
            "status": "done",
            "testStrategy": "Use Crystal's compile-time error detection, create code that should fail compilation when mixing types, verify type safety prevents operations between incompatible measurement types"
          },
          {
            "id": 5,
            "title": "Implement Equality and Inspection Methods",
            "description": "Add helper methods for equality comparison and string representation",
            "dependencies": [
              "2.3"
            ],
            "details": "Implement utility methods:\n- Override to_s to provide readable string representation like '10.5 kg'\n- Add inspect method for debugging that shows type parameters\n- Implement basic equality check (same unit and value)\n- Consider adding hash method for use in Hash keys\n- Ensure methods maintain immutability\n<info added on 2025-08-01T06:06:54.732Z>\nSuccessfully completed comprehensive implementation with full test coverage:\n\nImplementation Results:\n- All 5 core utility methods implemented with proper type safety\n- String representation methods handle full unit names (not abbreviations)\n- Inspect method provides detailed phantom type debugging information\n- Equality operates only within same phantom type constraints\n- Hash implementation ensures collection compatibility\n\nTesting Achievements:\n- Expanded test suite from 27 to 40 total tests\n- 100% method coverage for utility functionality\n- Comprehensive edge case testing including negative values\n- Hash collection integration verified\n- All tests passing with no regressions\n\nCode Quality:\n- Maintained immutability principles throughout\n- Preserved phantom type safety constraints\n- Clean method implementations following Crystal conventions\n- Proper error handling and type constraints\n- Ready for integration with comparison and arithmetic operations\n</info added on 2025-08-01T06:06:54.732Z>",
            "status": "done",
            "testStrategy": "Test string representations with various values and units, verify inspect shows type information, test equality with same/different units and values, test hash consistency"
          }
        ]
      },
      {
        "id": 3,
        "title": "Create Unit Enum System for Weight",
        "description": "Implement the Weight measurement type with comprehensive unit enums and conversion factors",
        "details": "Create src/unit/measurements/weight.cr:\n```crystal\nmodule Unit\n  class Weight < Measurement(Weight, Weight::Unit)\n    enum Unit\n      Gram\n      Kilogram\n      Milligram\n      Tonne\n      Pound\n      Ounce\n      Slug\n      \n      # Aliases\n      G = Gram\n      Kg = Kilogram\n      Mg = Milligram\n      T = Tonne\n      Lb = Pound\n      Oz = Ounce\n    end\n    \n    CONVERSION_FACTORS = {\n      Unit::Gram => BigDecimal.new(\"1\"),\n      Unit::Kilogram => BigDecimal.new(\"1000\"),\n      Unit::Milligram => BigDecimal.new(\"0.001\"),\n      Unit::Tonne => BigDecimal.new(\"1000000\"),\n      Unit::Pound => BigDecimal.new(\"453.59237\"),\n      Unit::Ounce => BigDecimal.new(\"28.349523125\"),\n      Unit::Slug => BigDecimal.new(\"14593.903\")\n    }\n  end\nend\n```\n- Use gram as the base unit for all conversions\n- Store precise conversion factors using BigDecimal\n- Implement both full names and common abbreviations as enum aliases",
        "testStrategy": "Test all enum values are accessible, verify conversion factors against NIST standards, test enum aliases work correctly, ensure compile-time type checking for Weight::Unit",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Weight Module Structure and Unit Enum",
            "description": "Set up the basic Weight class structure with the Unit enum containing all weight units and their aliases",
            "dependencies": [],
            "details": "Create the file src/unit/measurements/weight.cr and implement the Weight class that inherits from Measurement(Weight, Weight::Unit). Define the Unit enum with all weight units: Gram, Kilogram, Milligram, Tonne, Pound, Ounce, and Slug. Also implement the enum aliases (G, Kg, Mg, T, Lb, Oz) for convenience. Ensure the module structure follows the established pattern from the base Measurement class.",
            "status": "done",
            "testStrategy": "Write tests to verify that all enum values are accessible through both full names and aliases, test that Weight::Unit is a valid type, and ensure the class properly inherits from Measurement"
          },
          {
            "id": 2,
            "title": "Implement Conversion Factors with BigDecimal Precision",
            "description": "Define the CONVERSION_FACTORS constant with precise conversion values using BigDecimal for all weight units",
            "dependencies": [
              "3.1"
            ],
            "details": "Implement the CONVERSION_FACTORS hash constant that maps each Unit enum value to its conversion factor relative to grams (the base unit). Use BigDecimal for all values to ensure precision: Gram => 1, Kilogram => 1000, Milligram => 0.001, Tonne => 1000000, Pound => 453.59237, Ounce => 28.349523125, Slug => 14593.903. Research and verify these conversion factors against NIST standards to ensure accuracy.",
            "status": "done",
            "testStrategy": "Test each conversion factor against NIST reference values, verify BigDecimal precision is maintained, test edge cases with very large and very small values"
          },
          {
            "id": 3,
            "title": "Add Metric System Validation and Conversion Logic",
            "description": "Implement methods to identify metric units and optimize conversions within the metric system",
            "dependencies": [
              "3.1",
              "3.2"
            ],
            "details": "Add helper methods to identify which units belong to the metric system (gram, kilogram, milligram, tonne) and implement optimized conversion logic for metric-to-metric conversions. This could include methods like `metric?` on the Unit enum and special handling in the conversion logic to avoid unnecessary precision loss when converting between metric units.",
            "status": "done",
            "testStrategy": "Test metric unit identification, verify metric-to-metric conversions maintain exact precision, test that mixed metric/imperial conversions work correctly"
          },
          {
            "id": 4,
            "title": "Implement Imperial Unit Conversions and Relationships",
            "description": "Add specialized handling for imperial unit conversions and their relationships",
            "dependencies": [
              "3.1",
              "3.2"
            ],
            "details": "Implement additional logic for imperial units (pound, ounce) including their relationships (16 ounces = 1 pound). Consider adding convenience methods for common conversions and ensure proper handling of the slug unit which is less common but important for physics calculations. Add validation to ensure conversion accuracy between imperial units.",
            "status": "done",
            "testStrategy": "Test pound-to-ounce conversions match expected 16:1 ratio, verify slug conversions for physics calculations, test round-trip conversions between imperial units"
          },
          {
            "id": 5,
            "title": "Add Unit Symbol Support and String Representations",
            "description": "Implement methods to get standard symbols and string representations for each weight unit",
            "dependencies": [
              "3.1"
            ],
            "details": "Add methods to the Unit enum to return standard symbols (e.g., 'g' for gram, 'kg' for kilogram, 'lb' for pound) and full string representations. This should include both singular and plural forms, and potentially support for different formatting styles (abbreviated vs full). Consider implementing a `to_s` method and a `symbol` method on the enum.",
            "status": "done",
            "testStrategy": "Test that each unit returns the correct symbol and string representation, verify singular/plural forms work correctly, test integration with the base Measurement class formatting"
          }
        ]
      },
      {
        "id": 4,
        "title": "Create Unit Enum System for Length",
        "description": "Implement the Length measurement type with metric and imperial units",
        "details": "Create src/unit/measurements/length.cr:\n```crystal\nmodule Unit\n  class Length < Measurement(Length, Length::Unit)\n    enum Unit\n      Meter\n      Centimeter\n      Millimeter\n      Kilometer\n      Inch\n      Foot\n      Yard\n      Mile\n      \n      # Aliases\n      M = Meter\n      Cm = Centimeter\n      Mm = Millimeter\n      Km = Kilometer\n      In = Inch\n      Ft = Foot\n      Yd = Yard\n      Mi = Mile\n    end\n    \n    CONVERSION_FACTORS = {\n      Unit::Meter => BigDecimal.new(\"1\"),\n      Unit::Centimeter => BigDecimal.new(\"0.01\"),\n      Unit::Millimeter => BigDecimal.new(\"0.001\"),\n      Unit::Kilometer => BigDecimal.new(\"1000\"),\n      Unit::Inch => BigDecimal.new(\"0.0254\"),\n      Unit::Foot => BigDecimal.new(\"0.3048\"),\n      Unit::Yard => BigDecimal.new(\"0.9144\"),\n      Unit::Mile => BigDecimal.new(\"1609.344\")\n    }\n  end\nend\n```\n- Use meter as the base unit\n- Include both metric (SI) and imperial units\n- Store exact conversion factors per international standards",
        "testStrategy": "Verify conversion factors against ISO 31-1 standards, test all unit enums and aliases, cross-check imperial to metric conversions for accuracy",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Length measurement class file structure",
            "description": "Set up the basic file structure and module hierarchy for the Length measurement type",
            "dependencies": [],
            "details": "Create the file src/unit/measurements/length.cr and establish the module Unit namespace. Define the Length class that inherits from Measurement(Length, Length::Unit). This will serve as the foundation for the Length measurement implementation.",
            "status": "done",
            "testStrategy": "Verify the file exists at the correct path, ensure the module and class compile without errors, confirm the inheritance chain is properly established"
          },
          {
            "id": 2,
            "title": "Define Length Unit enum with metric and imperial units",
            "description": "Implement the Unit enum inside the Length class with all required metric and imperial length units",
            "dependencies": [
              "4.1"
            ],
            "details": "Define the Unit enum with values: Meter, Centimeter, Millimeter, Kilometer (metric) and Inch, Foot, Yard, Mile (imperial). Also create short aliases for convenience: M = Meter, Cm = Centimeter, Mm = Millimeter, Km = Kilometer, In = Inch, Ft = Foot, Yd = Yard, Mi = Mile. Ensure the enum follows Crystal's naming conventions and is properly scoped within the Length class.",
            "status": "done",
            "testStrategy": "Test that all enum values are accessible (e.g., Length::Unit::Meter), verify aliases work correctly (Length::Unit::M == Length::Unit::Meter), ensure enum values can be used in type annotations"
          },
          {
            "id": 3,
            "title": "Implement CONVERSION_FACTORS hash with precise values",
            "description": "Create the CONVERSION_FACTORS constant hash mapping each unit to its conversion factor relative to meters",
            "dependencies": [
              "4.2"
            ],
            "details": "Define CONVERSION_FACTORS as a Hash(Unit, BigDecimal) with meter as the base unit (factor 1.0). Include precise conversion factors based on international standards: Meter => 1, Centimeter => 0.01, Millimeter => 0.001, Kilometer => 1000, Inch => 0.0254 (exactly), Foot => 0.3048 (exactly), Yard => 0.9144 (exactly), Mile => 1609.344 (exactly). Use BigDecimal for all values to ensure precision.",
            "status": "done",
            "testStrategy": "Verify all conversion factors against ISO 31-1 and NIST standards, test that BigDecimal precision is maintained, ensure no floating-point errors in conversions"
          },
          {
            "id": 4,
            "title": "Add unit validation and base unit methods",
            "description": "Implement methods to validate units and identify the base unit for the Length measurement type",
            "dependencies": [
              "4.3"
            ],
            "details": "Add a class method `base_unit` that returns Unit::Meter. Implement a `valid_unit?` method that checks if a given unit belongs to Length::Unit enum. Add a `conversion_factor` method that returns the BigDecimal conversion factor for a given unit from the CONVERSION_FACTORS hash. These methods will be used by the parent Measurement class for conversions.",
            "status": "done",
            "testStrategy": "Test base_unit returns Unit::Meter, verify valid_unit? returns true for all Length units and false for invalid units, ensure conversion_factor returns correct BigDecimal values"
          },
          {
            "id": 5,
            "title": "Create comprehensive unit tests for Length measurement",
            "description": "Write thorough spec tests covering all aspects of the Length measurement implementation",
            "dependencies": [
              "4.4"
            ],
            "details": "Create spec/unit/measurements/length_spec.cr with tests for: enum value accessibility, alias functionality, conversion factor accuracy (comparing against known standards), base unit identification, and integration with the Measurement parent class. Include edge cases like very large/small conversions and ensure BigDecimal precision is maintained throughout.",
            "status": "done",
            "testStrategy": "Run all specs with 'crystal spec', verify 100% code coverage for length.cr, cross-validate conversion results with external calculators, test both metric-to-metric and metric-to-imperial conversions"
          }
        ]
      },
      {
        "id": 5,
        "title": "Create Unit Enum System for Volume",
        "description": "Implement the Volume measurement type with liquid volume units",
        "details": "Create src/unit/measurements/volume.cr:\n```crystal\nmodule Unit\n  class Volume < Measurement(Volume, Volume::Unit)\n    enum Unit\n      Liter\n      Milliliter\n      Gallon\n      Quart\n      Pint\n      Cup\n      FluidOunce\n      \n      # Aliases\n      L = Liter\n      Ml = Milliliter\n      Gal = Gallon\n      Qt = Quart\n      Pt = Pint\n      FlOz = FluidOunce\n    end\n    \n    CONVERSION_FACTORS = {\n      Unit::Liter => BigDecimal.new(\"1\"),\n      Unit::Milliliter => BigDecimal.new(\"0.001\"),\n      Unit::Gallon => BigDecimal.new(\"3.785411784\"),  # US gallon\n      Unit::Quart => BigDecimal.new(\"0.946352946\"),   # US quart\n      Unit::Pint => BigDecimal.new(\"0.473176473\"),    # US pint\n      Unit::Cup => BigDecimal.new(\"0.2365882365\"),    # US cup\n      Unit::FluidOunce => BigDecimal.new(\"0.0295735295735\") # US fl oz\n    }\n  end\nend\n```\n- Use liter as base unit\n- Focus on US liquid measurements (can add UK imperial in future)\n- Maintain high precision for cooking/recipe applications",
        "testStrategy": "Test conversions against NIST Handbook 44, verify US liquid measurement relationships (1 gal = 4 qt = 8 pt = 16 cups), test precision for common recipe conversions",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Volume measurement file structure",
            "description": "Set up the Volume measurement class file with proper module structure and imports",
            "dependencies": [],
            "details": "Create src/unit/measurements/volume.cr file with the Unit module namespace. Import required dependencies including BigDecimal for precision calculations and the base Measurement class. Set up the class definition extending from Measurement(Volume, Volume::Unit) to establish the generic type constraints.",
            "status": "done",
            "testStrategy": "Verify file exists at correct path, ensure module structure compiles without errors, confirm proper inheritance from Measurement base class"
          },
          {
            "id": 2,
            "title": "Define Volume Unit enum with US liquid measurements",
            "description": "Implement the Unit enum containing all US liquid volume units and their aliases",
            "dependencies": [
              "5.1"
            ],
            "details": "Define the Unit enum within the Volume class containing: Liter, Milliliter, Gallon, Quart, Pint, Cup, and FluidOunce. Add shorter aliases: L = Liter, Ml = Milliliter, Gal = Gallon, Qt = Quart, Pt = Pint, FlOz = FluidOunce. Ensure enum values follow Crystal naming conventions and are accessible as Volume::Unit members.",
            "status": "done",
            "testStrategy": "Test each enum value can be accessed (e.g., Volume::Unit::Liter), verify aliases resolve to correct enum values, ensure all units are unique and properly defined"
          },
          {
            "id": 3,
            "title": "Implement CONVERSION_FACTORS with high-precision values",
            "description": "Create the conversion factors hash with BigDecimal values for accurate conversions",
            "dependencies": [
              "5.2"
            ],
            "details": "Define CONVERSION_FACTORS constant hash mapping each Unit enum to its BigDecimal conversion factor to liters (base unit). Use high-precision values: Liter = 1, Milliliter = 0.001, Gallon = 3.785411784 (US), Quart = 0.946352946 (US), Pint = 0.473176473 (US), Cup = 0.2365882365 (US), FluidOunce = 0.0295735295735 (US). Ensure all values are wrapped in BigDecimal.new() for precision.",
            "status": "done",
            "testStrategy": "Verify conversion factors against NIST Handbook 44 standards, test precision is maintained in calculations, validate US liquid measurement relationships (1 gallon = 4 quarts = 8 pints = 16 cups = 128 fl oz)"
          },
          {
            "id": 4,
            "title": "Add Volume-specific conversion validations",
            "description": "Implement validation logic to ensure volume conversions maintain precision for cooking/recipe applications",
            "dependencies": [
              "5.3"
            ],
            "details": "Override or extend any necessary methods from the base Measurement class to ensure volume conversions maintain required precision for cooking applications. Consider adding validation for common recipe conversions (e.g., tablespoons to cups, teaspoons to milliliters if needed in future). Ensure conversion methods handle edge cases like very small volumes (drops) or very large volumes (industrial quantities).",
            "status": "done",
            "testStrategy": "Test common recipe conversions for accuracy (1 cup = 16 tablespoons = 48 teaspoons), verify precision is maintained for small volume conversions, test boundary conditions with very large and very small values"
          },
          {
            "id": 5,
            "title": "Document Volume class with usage examples",
            "description": "Add comprehensive documentation and code examples for the Volume measurement type",
            "dependencies": [
              "5.4"
            ],
            "details": "Add Crystal documentation comments to the Volume class explaining its purpose, supported units, and precision guarantees. Include code examples showing: creating volume measurements (Volume.new(2.5, :cups)), converting between units (volume.to(:liters)), and common recipe conversions. Document that this implementation focuses on US liquid measurements with notes about future UK imperial support. Add notes about precision requirements for cooking applications.",
            "status": "done",
            "testStrategy": "Verify all documentation examples compile and run correctly, ensure examples cover common use cases, validate that generated API docs include all public methods and constants"
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement Unit Conversion System",
        "description": "Create the conversion module for transforming between units within the same measurement type",
        "details": "Create src/unit/conversion.cr:\n```crystal\nmodule Unit\n  module Conversion\n    def convert_to(target_unit : U) : self\n      return self if @unit == target_unit\n      \n      # Convert to base unit, then to target\n      base_value = to_base_unit_value\n      target_factor = self.class::CONVERSION_FACTORS[target_unit]\n      new_value = base_value / target_factor\n      \n      self.class.new(new_value, target_unit)\n    end\n    \n    def to(target_unit : U) : self\n      convert_to(target_unit)\n    end\n    \n    private def to_base_unit_value : BigDecimal\n      @value * self.class::CONVERSION_FACTORS[@unit]\n    end\n  end\nend\n```\n- Include this module in Measurement class\n- Implement two-step conversion: source → base → target\n- Cache conversion results for repeated operations\n- Add alias method `to` for more natural API",
        "testStrategy": "Test round-trip conversions maintain precision, verify conversion accuracy with known values, test edge cases (very large/small numbers), benchmark conversion performance",
        "priority": "high",
        "dependencies": [
          3,
          4,
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create conversion module file and basic structure",
            "description": "Set up the src/unit/conversion.cr file with the module structure and namespace",
            "dependencies": [],
            "details": "Create the file src/unit/conversion.cr and define the module Unit::Conversion with proper Crystal module syntax. This will serve as the foundation for all conversion functionality.",
            "status": "done",
            "testStrategy": "Verify the file exists and can be required without syntax errors"
          },
          {
            "id": 2,
            "title": "Implement convert_to method with unit conversion logic",
            "description": "Create the main convert_to method that handles the two-step conversion process",
            "dependencies": [
              "6.1"
            ],
            "details": "Implement the convert_to method that: 1) Returns self if units match, 2) Converts the current value to base unit value using to_base_unit_value, 3) Gets the target unit's conversion factor from CONVERSION_FACTORS, 4) Calculates the new value by dividing base value by target factor, 5) Returns a new instance with converted value and target unit",
            "status": "done",
            "testStrategy": "Test conversions between different units within the same measurement type, verify accuracy with known conversion values (e.g., 1 meter = 100 centimeters), test identity conversion (same unit returns self)"
          },
          {
            "id": 3,
            "title": "Implement to_base_unit_value private method",
            "description": "Create the helper method that converts any unit value to its base unit representation",
            "dependencies": [
              "6.1"
            ],
            "details": "Implement the private to_base_unit_value method that multiplies the current value by the conversion factor for the current unit from CONVERSION_FACTORS. This method is crucial for the two-step conversion process and should handle BigDecimal arithmetic for precision.",
            "status": "done",
            "testStrategy": "Test base unit conversions for various units, verify precision is maintained with BigDecimal operations, test with edge cases like very large and very small numbers"
          },
          {
            "id": 4,
            "title": "Add the 'to' alias method for natural API",
            "description": "Create the 'to' method as an alias for convert_to to provide a more fluent API",
            "dependencies": [
              "6.2"
            ],
            "details": "Implement the 'to' method that simply delegates to convert_to, allowing users to write more natural expressions like 'distance.to(:meters)' instead of 'distance.convert_to(:meters)'",
            "status": "done",
            "testStrategy": "Verify that 'to' method produces identical results to 'convert_to', test that both methods accept the same parameter types"
          },
          {
            "id": 5,
            "title": "Include Conversion module in Measurement class",
            "description": "Integrate the Conversion module into the Measurement class to enable conversion functionality",
            "dependencies": [
              "6.1",
              "6.2",
              "6.3",
              "6.4"
            ],
            "details": "Update the Measurement class definition to include Unit::Conversion module. Ensure the module has access to necessary instance variables (@value, @unit) and class constants (CONVERSION_FACTORS). May need to add any necessary accessor methods if not already present.",
            "status": "done",
            "testStrategy": "Test that Measurement instances respond to convert_to and to methods, verify conversions work correctly through the Measurement interface, test round-trip conversions maintain precision"
          }
        ]
      },
      {
        "id": 7,
        "title": "Implement Arithmetic Operations Module",
        "description": "Add support for addition, subtraction, and scaling operations on measurements",
        "details": "Create src/unit/arithmetic.cr:\n```crystal\nmodule Unit\n  module Arithmetic\n    def +(other : self) : self\n      if @unit == other.unit\n        self.class.new(@value + other.value, @unit)\n      else\n        converted = other.convert_to(@unit)\n        self.class.new(@value + converted.value, @unit)\n      end\n    end\n    \n    def -(other : self) : self\n      if @unit == other.unit\n        self.class.new(@value - other.value, @unit)\n      else\n        converted = other.convert_to(@unit)\n        self.class.new(@value - converted.value, @unit)\n      end\n    end\n    \n    def *(scalar : Number) : self\n      self.class.new(@value * BigDecimal.new(scalar.to_s), @unit)\n    end\n    \n    def /(scalar : Number) : self\n      raise ArgumentError.new(\"Cannot divide by zero\") if scalar == 0\n      self.class.new(@value / BigDecimal.new(scalar.to_s), @unit)\n    end\n  end\nend\n```\n- Automatically convert units during operations\n- Maintain immutability by returning new instances\n- Preserve precision using BigDecimal arithmetic\n- Result maintains the unit of the left operand",
        "testStrategy": "Test operations with same units, test automatic conversion with different units, verify precision preservation, test zero division handling, verify compile-time type safety prevents cross-type operations",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Arithmetic Module Structure",
            "description": "Set up the basic module structure and file organization for arithmetic operations",
            "dependencies": [],
            "details": "Create src/unit/arithmetic.cr file and define the Unit::Arithmetic module. Set up the module structure that will be included in the Measurement class. Ensure proper module namespacing and file organization following Crystal conventions.",
            "status": "done",
            "testStrategy": "Verify module can be required and included without errors, check module is properly namespaced under Unit"
          },
          {
            "id": 2,
            "title": "Implement Addition Operation",
            "description": "Implement the + operator for adding measurements with automatic unit conversion",
            "dependencies": [
              "7.1"
            ],
            "details": "Implement the + method that handles both same-unit and different-unit additions. When units differ, convert the right operand to match the left operand's unit using the convert_to method. Return a new instance to maintain immutability. Use BigDecimal for precision.",
            "status": "done",
            "testStrategy": "Test addition with same units (5kg + 3kg = 8kg), test with different units (1m + 100cm = 2m), verify immutability by checking original objects remain unchanged, test precision with decimal values"
          },
          {
            "id": 3,
            "title": "Implement Subtraction Operation",
            "description": "Implement the - operator for subtracting measurements with automatic unit conversion",
            "dependencies": [
              "7.1"
            ],
            "details": "Implement the - method following the same pattern as addition. Handle unit conversion when units differ, maintain immutability by returning new instances, and use BigDecimal arithmetic for precision. Ensure proper handling of negative results.",
            "status": "done",
            "testStrategy": "Test subtraction with same units (10kg - 3kg = 7kg), test with different units (2m - 50cm = 1.5m), verify negative results work correctly (3kg - 5kg = -2kg), test precision preservation"
          },
          {
            "id": 4,
            "title": "Implement Scalar Multiplication and Division",
            "description": "Implement * and / operators for scaling measurements by numeric values",
            "dependencies": [
              "7.1"
            ],
            "details": "Implement multiplication (*) operator that accepts any Number type and converts it to BigDecimal for precision. Implement division (/) operator with zero-division protection. Both operations should return new instances with the same unit as the original measurement.",
            "status": "done",
            "testStrategy": "Test multiplication with integers and floats (5kg * 2 = 10kg, 3m * 1.5 = 4.5m), test division (10kg / 2 = 5kg), verify ArgumentError is raised for division by zero, test precision with BigDecimal operations"
          },
          {
            "id": 5,
            "title": "Integration Testing and Documentation",
            "description": "Write comprehensive integration tests and add inline documentation for the arithmetic module",
            "dependencies": [
              "7.2",
              "7.3",
              "7.4"
            ],
            "details": "Create spec/unit/arithmetic_spec.cr with comprehensive tests covering all arithmetic operations. Test edge cases including very large/small numbers, chained operations, and mixed unit calculations. Add Crystal doc comments to all public methods explaining usage and examples.",
            "status": "done",
            "testStrategy": "Run full test suite ensuring 100% code coverage, test chained operations (a + b - c), verify compile-time type safety prevents invalid operations, benchmark arithmetic performance with large datasets"
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement Comparison Operations",
        "description": "Add equality and ordering comparisons with automatic unit conversion",
        "details": "Update measurement.cr to include Comparable and add:\n```crystal\nmodule Unit\n  class Measurement(T, U)\n    include Comparable(self)\n    \n    def <=>(other : self) : Int32\n      if @unit == other.unit\n        @value <=> other.value\n      else\n        converted = other.convert_to(@unit)\n        @value <=> converted.value\n      end\n    end\n    \n    def ==(other : self) : Bool\n      if @unit == other.unit\n        @value == other.value\n      else\n        converted = other.convert_to(@unit)\n        @value == converted.value\n      end\n    end\n    \n    def hash : UInt64\n      # Ensure equal measurements have equal hashes\n      base_value = to_base_unit_value\n      {T.name, base_value.to_s}.hash\n    end\n  end\nend\n```\n- Implement Comparable for full ordering support\n- Auto-convert for cross-unit comparisons\n- Ensure hash equality for equal measurements regardless of unit",
        "testStrategy": "Test comparisons across different units, verify hash equality for equivalent measurements, test sorting arrays of measurements, verify Comparable methods work correctly",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Include Comparable Module in Measurement Class",
            "description": "Add the Comparable module inclusion to the Measurement class to enable ordering operations",
            "dependencies": [],
            "details": "Update src/unit/measurement.cr to include Comparable(self) at the class level. This will provide the foundation for comparison operators and enable the Measurement class to be used in sorted collections. The inclusion should be placed after the class declaration and before any method definitions.",
            "status": "done",
            "testStrategy": "Create a test to verify that all Comparable methods (<=>, <, >, <=, >=, between?) are available on Measurement instances. Test that the module inclusion doesn't break existing functionality."
          },
          {
            "id": 2,
            "title": "Implement Spaceship Operator with Unit Conversion",
            "description": "Implement the <=> operator that handles automatic unit conversion for cross-unit comparisons",
            "dependencies": [
              "8.1"
            ],
            "details": "Add the <=> method to Measurement class that compares values directly when units match, or converts the other measurement to this unit before comparison. The method should return -1, 0, or 1 as per Crystal's Comparable protocol. Handle the conversion using the existing convert_to method and ensure proper error handling for incompatible unit conversions.",
            "status": "done",
            "testStrategy": "Test comparisons between measurements with same units, different compatible units, and verify that incompatible unit comparisons raise appropriate errors. Test edge cases like comparing zero values and very large/small numbers."
          },
          {
            "id": 3,
            "title": "Implement Equality Operator with Unit Conversion",
            "description": "Create the == operator that properly compares measurements across different units",
            "dependencies": [
              "8.1"
            ],
            "details": "Implement the == method that returns true only when measurements represent the same quantity, regardless of their units. For same-unit comparisons, compare values directly. For different units, convert one measurement to the other's unit before comparison. This should handle floating-point precision issues appropriately by using BigDecimal comparisons.",
            "status": "done",
            "testStrategy": "Test equality between identical measurements, equivalent measurements in different units (e.g., 1000g == 1kg), and non-equal measurements. Verify that precision is handled correctly for converted values."
          },
          {
            "id": 4,
            "title": "Implement Hash Method for Consistent Hashing",
            "description": "Create a hash method that ensures equal measurements produce equal hash values regardless of their units",
            "dependencies": [
              "8.3"
            ],
            "details": "Implement the hash method that converts the measurement to its base unit value before hashing. This ensures that 1000g and 1kg produce the same hash value. The hash should combine the type name (T.name) and the base unit value string representation to create a unique hash. Use Crystal's built-in hash method on the tuple of these values.",
            "status": "done",
            "testStrategy": "Verify that equivalent measurements in different units produce identical hash values. Test that measurements can be used as Hash keys and that equivalent measurements access the same hash entry. Test with various numeric values including edge cases."
          },
          {
            "id": 5,
            "title": "Add Comprehensive Comparison Tests",
            "description": "Create a comprehensive test suite for all comparison operations including sorting and hash behavior",
            "dependencies": [
              "8.2",
              "8.3",
              "8.4"
            ],
            "details": "Write tests in spec/unit/measurement_spec.cr covering: sorting arrays of mixed-unit measurements, using measurements in Set and Hash collections, all Comparable methods (<, >, <=, >=, between?), equality across units, and hash consistency. Include edge cases like comparing measurements with very small differences and ensure proper behavior with BigDecimal precision.",
            "status": "done",
            "testStrategy": "Create test cases for sorting measurements of different units, verify Set uniqueness based on value equivalence, test Hash key behavior with equivalent measurements, and ensure all comparison operators work correctly with automatic conversion."
          }
        ]
      },
      {
        "id": 9,
        "title": "Implement String Parsing System",
        "description": "Create parser for converting strings like '10.5 kg' into measurement objects",
        "details": "Create src/unit/parser.cr:\n```crystal\nmodule Unit\n  module Parser\n    FRACTION_REGEX = /^(\\d+)\\s*\\/\\s*(\\d+)$/\n    DECIMAL_REGEX = /^(-?\\d+\\.?\\d*)$/\n    MEASUREMENT_REGEX = /^\\s*(-?\\d+\\.?\\d*|\\d+\\s*\\/\\s*\\d+)\\s+(.+?)\\s*$/\n    \n    def self.parse(T : Class, input : String) : T\n      match = MEASUREMENT_REGEX.match(input.strip)\n      raise ArgumentError.new(\"Invalid format: #{input}\") unless match\n      \n      value_str = match[1]\n      unit_str = match[2].downcase\n      \n      # Parse value (handle fractions)\n      value = if fraction_match = FRACTION_REGEX.match(value_str)\n        BigRational.new(fraction_match[1].to_i, fraction_match[2].to_i)\n      else\n        BigDecimal.new(value_str)\n      end\n      \n      # Parse unit\n      unit = parse_unit(T, unit_str)\n      T.new(value, unit)\n    end\n    \n    private def self.parse_unit(T : Class, unit_str : String)\n      # Match against unit names and aliases\n      T::Unit.each do |unit|\n        return unit if unit.to_s.downcase == unit_str\n      end\n      raise ArgumentError.new(\"Unknown unit: #{unit_str}\")\n    end\n  end\nend\n```\n- Support decimal and fractional notation\n- Handle various spacing patterns\n- Case-insensitive unit matching\n- Clear error messages for invalid input",
        "testStrategy": "Test parsing various formats: '10 kg', '10.5 pounds', '1/2 lb', '3.14159m', test error handling for invalid formats, test whitespace handling, verify fraction precision",
        "priority": "medium",
        "dependencies": [
          3,
          4,
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Parser Module Structure and Basic Regex Patterns",
            "description": "Set up the Unit::Parser module with regex patterns for fractions, decimals, and measurements",
            "dependencies": [],
            "details": "Create src/unit/parser.cr file and implement the Unit::Parser module with three core regex patterns: FRACTION_REGEX for matching fraction notation (e.g., '1/2'), DECIMAL_REGEX for matching decimal numbers including negative values, and MEASUREMENT_REGEX for matching the complete measurement string format. Ensure the MEASUREMENT_REGEX can handle both decimal and fraction values followed by unit strings with flexible whitespace.",
            "status": "done",
            "testStrategy": "Create unit tests to verify each regex pattern matches expected formats: test FRACTION_REGEX with '1/2', '3/4', '10/3'; test DECIMAL_REGEX with '10', '-5.5', '0.001'; test MEASUREMENT_REGEX with '10 kg', '1/2 pound', '-3.14 meters'"
          },
          {
            "id": 2,
            "title": "Implement Value Parsing Logic with Fraction Support",
            "description": "Parse numeric values from strings, handling both decimal and fraction formats with BigDecimal/BigRational",
            "dependencies": [
              "9.1"
            ],
            "details": "Within the parse method, implement the value parsing logic that extracts the numeric portion from the regex match. Check if the value matches the fraction pattern first - if so, parse numerator and denominator and create a BigRational. Otherwise, parse as BigDecimal for decimal values. Ensure proper handling of negative values in both formats.",
            "status": "done",
            "testStrategy": "Test parsing various numeric formats: verify '1/2' creates BigRational(1,2), '10.5' creates BigDecimal('10.5'), '-3.14' creates negative BigDecimal, '0' and '1' parse correctly as edge cases"
          },
          {
            "id": 3,
            "title": "Implement Unit String Parsing and Matching",
            "description": "Create the parse_unit method to match unit strings against enum values with case-insensitive comparison",
            "dependencies": [
              "9.1"
            ],
            "details": "Implement the private parse_unit method that takes a measurement type class T and a unit string. Convert the unit string to lowercase for case-insensitive matching. Iterate through T::Unit enum values and compare each unit's string representation (converted to lowercase) with the input. Return the matching unit enum value when found. This should work generically for any measurement type (Weight, Length, etc.).",
            "status": "done",
            "testStrategy": "Test unit matching with various cases: 'kg' matches Kilogram, 'POUND' matches Pound, 'oz' matches Ounce; verify unknown units like 'xyz' raise ArgumentError"
          },
          {
            "id": 4,
            "title": "Complete Main Parse Method with Error Handling",
            "description": "Integrate value and unit parsing with proper error handling and validation",
            "dependencies": [
              "9.2",
              "9.3"
            ],
            "details": "Complete the main parse method that accepts a measurement type T and input string. Strip whitespace from input, apply MEASUREMENT_REGEX to extract value and unit parts. Call the value parsing logic to get BigDecimal or BigRational, then call parse_unit to get the unit enum. Create and return a new instance of T with the parsed value and unit. Include proper error handling with clear messages for invalid format (regex doesn't match) and unknown units.",
            "status": "done",
            "testStrategy": "Test complete parsing flow: '10.5 kg' creates Weight instance with value 10.5 and Unit::Kilogram; test error cases like 'invalid', '10', 'kg' (missing parts), '10 xyz' (unknown unit)"
          },
          {
            "id": 5,
            "title": "Add Support for Unit Aliases and Edge Cases",
            "description": "Enhance parser to handle unit aliases and various spacing/formatting edge cases",
            "dependencies": [
              "9.3",
              "9.4"
            ],
            "details": "Extend the parse_unit method to also check against unit aliases (e.g., 'g' for Gram, 'lb' for Pound). Handle edge cases like multiple spaces between value and unit, leading/trailing whitespace, and units with special characters. Consider adding support for plural forms (e.g., 'pounds' vs 'pound'). Ensure the parser remains performant even with these additional checks.",
            "status": "done",
            "testStrategy": "Test alias recognition: 'g' maps to Gram, 'lb' to Pound; test spacing variations: '10  kg', ' 10 kg ', '10\tkg'; test plural handling if implemented: '10 pounds' vs '10 pound'"
          }
        ]
      },
      {
        "id": 10,
        "title": "Implement String Formatting System",
        "description": "Create formatter for displaying measurements in various string formats",
        "details": "Create src/unit/formatter.cr:\n```crystal\nmodule Unit\n  module Formatter\n    def to_s(io : IO) : Nil\n      io << format\n    end\n    \n    def format(precision : Int32 = 2, unit_format : Symbol = :short) : String\n      formatted_value = format_value(precision)\n      unit_string = format_unit(unit_format)\n      \"#{formatted_value} #{unit_string}\"\n    end\n    \n    def humanize : String\n      value_str = @value == @value.to_i ? @value.to_i.to_s : @value.to_s(\"F\")\n      unit_name = @unit.to_s.underscore.gsub('_', ' ')\n      plural = @value == 1 ? \"\" : \"s\"\n      \"#{value_str} #{unit_name}#{plural}\"\n    end\n    \n    private def format_value(precision : Int32) : String\n      if @value == @value.to_i\n        @value.to_i.to_s\n      else\n        @value.round(precision).to_s(\"F\")\n      end\n    end\n    \n    private def format_unit(format : Symbol) : String\n      case format\n      when :short\n        # Use enum name or alias\n        @unit.to_s.downcase\n      when :long\n        @unit.to_s.underscore.gsub('_', ' ')\n      else\n        @unit.to_s\n      end\n    end\n  end\nend\n```\n- Support configurable decimal precision\n- Provide humanized output with pluralization\n- Smart formatting (no decimals for whole numbers)\n- Multiple unit display formats",
        "testStrategy": "Test various formatting options, verify pluralization rules, test precision handling, test edge cases (0, 1, negative values), verify io streaming",
        "priority": "medium",
        "dependencies": [
          3,
          4,
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Formatter Module Structure",
            "description": "Set up the base Formatter module file and integrate it with the Measurement class",
            "dependencies": [],
            "details": "Create src/unit/formatter.cr with the module structure and include it in the Measurement class. Ensure proper module nesting and namespace organization.",
            "status": "done",
            "testStrategy": "Verify module can be included in Measurement class, test that module methods are accessible"
          },
          {
            "id": 2,
            "title": "Implement Basic to_s and format Methods",
            "description": "Implement the core formatting methods including to_s(io) and format with precision and unit format options",
            "dependencies": [
              "10.1"
            ],
            "details": "Implement to_s(io : IO) for IO streaming support and format(precision, unit_format) method with configurable decimal precision and unit display formats (:short, :long). Handle whole number formatting without decimals.",
            "status": "done",
            "testStrategy": "Test IO streaming output, verify precision handling (0-10 decimals), test whole numbers display without decimals, verify different unit formats"
          },
          {
            "id": 3,
            "title": "Implement Humanize Method with Pluralization",
            "description": "Create the humanize method with intelligent pluralization rules for user-friendly output",
            "dependencies": [
              "10.1"
            ],
            "details": "Implement humanize method that converts unit names to human-readable format with proper pluralization. Handle edge cases like 1 (singular), 0 (plural), negative values, and fractional values. Convert enum names to readable format (e.g., Kilogram -> kilogram/kilograms).",
            "status": "done",
            "testStrategy": "Test pluralization for 0, 1, multiple values, negative values, and fractions. Verify unit name formatting from enums"
          },
          {
            "id": 4,
            "title": "Implement Private Helper Methods",
            "description": "Create format_value and format_unit private helper methods for consistent formatting logic",
            "dependencies": [
              "10.2"
            ],
            "details": "Implement format_value(precision) to handle BigDecimal formatting with configurable precision and smart whole number detection. Implement format_unit(format) to handle different unit display formats using enum methods like to_s, underscore transformations.",
            "status": "done",
            "testStrategy": "Test format_value with various precisions and number types, verify format_unit handles all format symbols correctly"
          },
          {
            "id": 5,
            "title": "Add Unit-Specific Format Customization",
            "description": "Extend formatter to support unit-specific formatting rules and aliases",
            "dependencies": [
              "10.4"
            ],
            "details": "Add support for unit-specific formatting rules, such as using unit aliases when available (e.g., kg instead of kilogram in short format). Ensure the formatter can access unit enum aliases and handle them appropriately in different format modes.",
            "status": "done",
            "testStrategy": "Test that unit aliases are used in short format, verify long format uses full names, test edge cases with units that don't have aliases"
          }
        ]
      },
      {
        "id": 11,
        "title": "Create Custom Exception Types",
        "description": "Implement domain-specific exception classes for better error handling",
        "details": "Create src/unit/exceptions.cr:\n```crystal\nmodule Unit\n  class UnitError < Exception\n  end\n  \n  class ConversionError < UnitError\n    def initialize(from_unit, to_unit, reason = nil)\n      message = \"Cannot convert from #{from_unit} to #{to_unit}\"\n      message += \": #{reason}\" if reason\n      super(message)\n    end\n  end\n  \n  class ParseError < UnitError\n    def initialize(input : String, reason = nil)\n      message = \"Cannot parse '#{input}' as measurement\"\n      message += \": #{reason}\" if reason\n      super(message)\n    end\n  end\n  \n  class ValidationError < UnitError\n    def initialize(message : String)\n      super(message)\n    end\n  end\n  \n  class ArithmeticError < UnitError\n    def initialize(operation : String, reason : String)\n      super(\"Arithmetic operation '#{operation}' failed: #{reason}\")\n    end\n  end\nend\n```\n- Create hierarchy of domain-specific exceptions\n- Include context in error messages\n- Make debugging easier with clear error types",
        "testStrategy": "Test each exception type can be raised and caught, verify error messages include context, test exception inheritance hierarchy",
        "priority": "low",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Base Exception Hierarchy",
            "description": "Create the foundational UnitError exception class and establish the inheritance structure",
            "dependencies": [],
            "details": "Implement the base UnitError class that inherits from Crystal's Exception class. This will serve as the parent class for all domain-specific exceptions in the Unit module. Include a basic constructor that accepts a message parameter and any common functionality that should be shared across all unit-related exceptions.",
            "status": "pending",
            "testStrategy": "Test that UnitError can be instantiated with a message, verify it inherits from Exception, ensure it can be caught in rescue blocks, and test that it provides appropriate stack trace information"
          },
          {
            "id": 2,
            "title": "Implement ConversionError Exception",
            "description": "Create specialized exception for unit conversion failures with contextual information",
            "dependencies": [
              "11.1"
            ],
            "details": "Implement ConversionError class that inherits from UnitError. The constructor should accept from_unit and to_unit parameters (as strings or unit types) and an optional reason parameter. Build informative error messages that clearly indicate which units failed to convert and why. Consider adding additional metadata fields that could help with debugging, such as the value being converted.",
            "status": "pending",
            "testStrategy": "Test initialization with various unit types, verify error messages are properly formatted with unit information, test with and without reason parameter, ensure the exception can be caught as both ConversionError and UnitError"
          },
          {
            "id": 3,
            "title": "Implement ParseError and ValidationError Exceptions",
            "description": "Create exceptions for parsing failures and validation errors with detailed context",
            "dependencies": [
              "11.1"
            ],
            "details": "Implement ParseError for when string inputs cannot be parsed into measurements, accepting the invalid input string and optional reason. Implement ValidationError for general validation failures like negative values where only positive are allowed, or values outside acceptable ranges. Both should provide clear, actionable error messages that help developers understand what went wrong.",
            "status": "pending",
            "testStrategy": "Test ParseError with various invalid input strings and verify error messages include the problematic input, test ValidationError with different validation scenarios, ensure both exceptions properly inherit from UnitError and can be rescued appropriately"
          },
          {
            "id": 4,
            "title": "Implement ArithmeticError Exception",
            "description": "Create specialized exception for arithmetic operation failures between measurements",
            "dependencies": [
              "11.1"
            ],
            "details": "Implement ArithmeticError class for when arithmetic operations fail, such as adding incompatible units or division by zero. The constructor should accept the operation name (e.g., 'addition', 'division') and a reason explaining the failure. Consider including the operands' types or units in the error message for better debugging context.",
            "status": "pending",
            "testStrategy": "Test with various arithmetic operations and failure reasons, verify error messages clearly indicate the operation and reason for failure, test that the exception can be caught at different levels of the exception hierarchy"
          },
          {
            "id": 5,
            "title": "Add Helper Methods and Documentation",
            "description": "Enhance exceptions with utility methods and comprehensive documentation",
            "dependencies": [
              "11.1",
              "11.2",
              "11.3",
              "11.4"
            ],
            "details": "Add helper methods to exceptions where appropriate, such as methods to extract unit information from ConversionError or the problematic input from ParseError. Document each exception class with Crystal doc comments explaining when they should be raised, what information they contain, and provide usage examples. Consider adding factory methods for common error scenarios to ensure consistent error messages across the codebase.",
            "status": "pending",
            "testStrategy": "Test all helper methods return expected values, verify documentation generates correctly with crystal docs, test factory methods produce consistent error messages, ensure examples in documentation compile and work as expected"
          }
        ]
      },
      {
        "id": 12,
        "title": "Implement Avram Integration Module",
        "description": "Create Lucky/Avram integration for database persistence of measurements",
        "details": "Create src/unit/integrations/avram.cr:\n```crystal\nmodule Unit\n  module Avram\n    macro measurement_column(name, type)\n      column {{name}}_value : Float64?\n      column {{name}}_unit : String?\n      \n      def {{name}} : {{type}}?\n        return nil unless {{name}}_value && {{name}}_unit\n        \n        unit_enum = {{type}}::Unit.parse({{name}}_unit.not_nil!)\n        {{type}}.new({{name}}_value.not_nil!, unit_enum)\n      rescue\n        nil\n      end\n      \n      def {{name}}=(measurement : {{type}}?)\n        if measurement\n          self.{{name}}_value = measurement.value.to_f64\n          self.{{name}}_unit = measurement.unit.to_s\n        else\n          self.{{name}}_value = nil\n          self.{{name}}_unit = nil\n        end\n      end\n    end\n    \n    module Validations\n      macro validate_measurement(name)\n        validate_required {{name}}_value, {{name}}_unit\n        \n        before_save do\n          if {{name}}_value && {{name}}_unit\n            {{name}}_unit_enum = {{type}}::Unit.parse?({{name}}_unit.not_nil!)\n            add_error(:{{name}}_unit, \"is not a valid unit\") unless {{name}}_unit_enum\n          end\n        end\n      end\n    end\n  end\nend\n```\n- Store as two columns: value (numeric) and unit (string)\n- Handle nullable measurement columns\n- Provide validation helpers\n- Auto-convert between database and object representation",
        "testStrategy": "Test with actual Avram models, verify nullable column handling, test validation of invalid units, test round-trip persistence, verify query capabilities",
        "priority": "low",
        "dependencies": [
          2,
          3,
          4,
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Avram module structure and measurement_column macro",
            "description": "Set up the base Avram integration module with the measurement_column macro that defines the two-column storage pattern",
            "dependencies": [],
            "details": "Create src/unit/integrations/avram.cr with the Unit::Avram module. Implement the measurement_column macro that generates two columns (_value and _unit) for each measurement field. The macro should define column declarations using Avram's column DSL for Float64? value storage and String? unit storage.",
            "status": "pending",
            "testStrategy": "Create a test Avram model with measurement columns, verify the macro generates correct column definitions, test that column names follow the pattern name_value and name_unit"
          },
          {
            "id": 2,
            "title": "Implement getter method for measurement reconstruction",
            "description": "Add the getter method generation to the measurement_column macro that reconstructs measurement objects from database columns",
            "dependencies": [
              "12.1"
            ],
            "details": "Within the measurement_column macro, generate a getter method that returns the appropriate measurement type or nil. The method should check if both _value and _unit columns have values, parse the unit string into the appropriate enum using Unit.parse, and construct a new measurement instance. Include error handling to return nil if parsing fails.",
            "status": "pending",
            "testStrategy": "Test getter with valid data returns correct measurement object, test with nil values returns nil, test with invalid unit strings returns nil, verify type safety with different measurement types"
          },
          {
            "id": 3,
            "title": "Implement setter method for measurement persistence",
            "description": "Add the setter method generation to store measurement objects as separate value and unit columns",
            "dependencies": [
              "12.1"
            ],
            "details": "Generate a setter method within the measurement_column macro that accepts a measurement object or nil. When given a measurement, extract the value as Float64 and unit as string, storing them in the respective columns. When given nil, set both columns to nil. Ensure the setter properly handles the conversion from BigDecimal to Float64.",
            "status": "pending",
            "testStrategy": "Test setter with valid measurement updates both columns, test with nil clears both columns, verify precision handling when converting BigDecimal to Float64, test with different measurement types"
          },
          {
            "id": 4,
            "title": "Create Validations module with validate_measurement macro",
            "description": "Implement the Validations module with helpers for validating measurement columns",
            "dependencies": [
              "12.1"
            ],
            "details": "Create the Unit::Avram::Validations module containing the validate_measurement macro. The macro should use Avram's validate_required for both value and unit fields when they should be present together. Add a before_save callback that validates the unit string can be parsed into a valid enum value, adding an error to the unit field if parsing fails.",
            "status": "pending",
            "testStrategy": "Test validation requires both or neither column to be present, test invalid unit strings add validation errors, test valid measurements pass validation, verify validation runs before save"
          },
          {
            "id": 5,
            "title": "Add query helpers and integration tests",
            "description": "Create query helpers for working with measurement columns and comprehensive integration tests",
            "dependencies": [
              "12.1",
              "12.2",
              "12.3",
              "12.4"
            ],
            "details": "Add helper methods or macros for common query operations like finding records within a measurement range or with specific units. Create integration tests using actual Avram models with different measurement types (Weight, Length, etc.) to verify the full persistence cycle, nullable column handling, and query capabilities.",
            "status": "pending",
            "testStrategy": "Test full CRUD operations with measurements, verify queries can filter by measurement values and units, test bulk operations maintain data integrity, test migration generation for measurement columns"
          }
        ]
      },
      {
        "id": 13,
        "title": "Create Migration Helpers for Avram",
        "description": "Implement database migration helpers for measurement columns",
        "details": "Create src/unit/integrations/avram/migration_helpers.cr:\n```crystal\nmodule Unit\n  module Avram\n    module MigrationHelpers\n      macro add_measurement_column(table, name, type, **options)\n        add {{name}}_value : Float64?, \n            precision: {{options[:precision] || 15}}, \n            scale: {{options[:scale] || 6}}\n        add {{name}}_unit : String, \n            size: {{options[:unit_size] || 20}}\n        \n        {% if options[:required] %}\n          alter table_for({{table}}) do\n            make_required {{name}}_value\n            make_required {{name}}_unit\n          end\n        {% end %}\n        \n        {% if options[:index] %}\n          create_index table_for({{table}}), :{{name}}_value\n        {% end %}\n      end\n      \n      macro remove_measurement_column(table, name)\n        alter table_for({{table}}) do\n          remove :{{name}}_value\n          remove :{{name}}_unit\n        end\n      end\n      \n      macro change_measurement_precision(table, name, precision, scale)\n        alter table_for({{table}}) do\n          change_type {{name}}_value : Float64, \n                      precision: {{precision}}, \n                      scale: {{scale}}\n        end\n      end\n    end\n  end\nend\n```\n- Provide macros for common migration operations\n- Support precision/scale configuration\n- Handle indexing for range queries\n- Include helpers for changing column properties",
        "testStrategy": "Test migration generation produces valid SQL, verify column constraints are applied correctly, test with various database adapters, verify rollback operations",
        "priority": "medium",
        "dependencies": [
          12
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Core Migration Macros",
            "description": "Create the base MigrationHelpers module with add_measurement_column and remove_measurement_column macros",
            "dependencies": [],
            "details": "Implement the core module structure and the two primary macros:\n- add_measurement_column: Creates both _value (Float64) and _unit (String) columns with configurable precision, scale, and unit field size\n- remove_measurement_column: Removes both associated columns\n- Ensure proper Crystal macro syntax with interpolation\n- Handle table_for resolution for Avram compatibility",
            "status": "pending",
            "testStrategy": "Create test migrations that use the macros, verify generated SQL contains correct column definitions, test with different precision/scale values, ensure both columns are created/removed together"
          },
          {
            "id": 2,
            "title": "Add Column Constraint Support",
            "description": "Implement support for required columns and null constraints in the migration macros",
            "dependencies": [
              "13.1"
            ],
            "details": "Extend add_measurement_column macro to handle:\n- :required option that makes both _value and _unit columns non-nullable\n- Use Avram's make_required within an alter block\n- Ensure constraints are applied after column creation\n- Handle edge cases where only one column needs to be required",
            "status": "pending",
            "testStrategy": "Test migrations with required: true option, verify NOT NULL constraints in generated SQL, test rollback removes constraints properly, verify error handling for null values"
          },
          {
            "id": 3,
            "title": "Implement Index Creation Support",
            "description": "Add indexing capabilities for measurement value columns to optimize range queries",
            "dependencies": [
              "13.1"
            ],
            "details": "Add index support to add_measurement_column:\n- Check for :index option in macro parameters\n- Create index only on _value column (numeric queries)\n- Use Avram's create_index with proper table reference\n- Consider composite indexes for value+unit if needed\n- Handle index naming conventions",
            "status": "pending",
            "testStrategy": "Test index creation with index: true option, verify index exists in database schema, benchmark query performance with/without indexes, test index removal on rollback"
          },
          {
            "id": 4,
            "title": "Create Column Modification Helpers",
            "description": "Implement change_measurement_precision macro for altering existing measurement columns",
            "dependencies": [
              "13.1"
            ],
            "details": "Create change_measurement_precision macro that:\n- Alters precision and scale of existing _value columns\n- Uses Avram's change_type within alter block\n- Preserves existing data while changing column properties\n- Handles potential data truncation warnings\n- Supports migration rollback",
            "status": "pending",
            "testStrategy": "Test changing precision on columns with existing data, verify data preservation within new constraints, test edge cases with values exceeding new precision, verify rollback restores original precision"
          },
          {
            "id": 5,
            "title": "Add Advanced Migration Helpers",
            "description": "Create additional helper macros for common measurement column operations",
            "dependencies": [
              "13.1",
              "13.2",
              "13.3",
              "13.4"
            ],
            "details": "Implement additional helpers:\n- add_measurement_index: Add index to existing measurement columns\n- rename_measurement_column: Rename both _value and _unit columns atomically\n- add_measurement_default: Set default values for measurement columns\n- add_measurement_check_constraint: Add CHECK constraints for valid ranges\n- migrate_to_measurement: Convert existing single columns to measurement pairs",
            "status": "pending",
            "testStrategy": "Test each helper macro individually, verify atomic operations for paired columns, test complex migrations using multiple helpers, ensure all operations are reversible"
          }
        ]
      },
      {
        "id": 14,
        "title": "Implement Serialization Support",
        "description": "Add JSON and YAML serialization support for measurements",
        "details": "Update measurement classes with:\n```crystal\nrequire \"json\"\nrequire \"yaml\"\n\nmodule Unit\n  class Measurement(T, U)\n    include JSON::Serializable\n    include YAML::Serializable\n    \n    @[JSON::Field(key: \"value\")]\n    @[YAML::Field(key: \"value\")]\n    getter value : BigDecimal\n    \n    @[JSON::Field(key: \"unit\", converter: Unit::EnumConverter(U))]\n    @[YAML::Field(key: \"unit\", converter: Unit::EnumConverter(U))]\n    getter unit : U\n    \n    def to_json(json : JSON::Builder)\n      json.object do\n        json.field \"value\", @value.to_s\n        json.field \"unit\", @unit.to_s\n        json.field \"type\", T.name\n      end\n    end\n  end\n  \n  # Custom converter for enum serialization\n  module EnumConverter(T)\n    def self.from_json(parser : JSON::PullParser) : T\n      T.parse(parser.read_string)\n    end\n    \n    def self.to_json(value : T, json : JSON::Builder)\n      json.string(value.to_s)\n    end\n  end\nend\n```\n- Support both JSON and YAML formats\n- Preserve precision in serialization\n- Include type information for deserialization\n- Handle enum conversion properly",
        "testStrategy": "Test round-trip serialization preserves values and units, verify precision is maintained, test with various numeric types, ensure invalid JSON/YAML raises appropriate errors",
        "priority": "medium",
        "dependencies": [
          2,
          3,
          4,
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create EnumConverter Module for JSON/YAML Serialization",
            "description": "Implement a generic EnumConverter module that handles serialization and deserialization of enum values for both JSON and YAML formats",
            "dependencies": [],
            "details": "Create src/unit/enum_converter.cr with:\n- Generic module EnumConverter(T) that works with any enum type\n- from_json method that parses string values to enum using T.parse\n- to_json method that converts enum to string representation\n- from_yaml and to_yaml methods with similar functionality\n- Error handling for invalid enum values during deserialization\n- Support for both uppercase and lowercase enum string values",
            "status": "pending",
            "testStrategy": "Test enum conversion with various Weight::Unit and Length::Unit values, verify invalid strings raise proper errors, test case-insensitive parsing, ensure round-trip conversion preserves exact enum values"
          },
          {
            "id": 2,
            "title": "Add JSON Serialization Support to Measurement Class",
            "description": "Implement JSON::Serializable module inclusion and custom to_json method in the Measurement class",
            "dependencies": [
              "14.1"
            ],
            "details": "Update src/unit/measurement.cr to:\n- Include JSON::Serializable module\n- Add @[JSON::Field] annotations for value and unit fields\n- Implement custom to_json method that outputs value as string to preserve BigDecimal precision\n- Include measurement type information (T.name) in JSON output\n- Use EnumConverter for unit field serialization\n- Ensure value is serialized as string to maintain full precision",
            "status": "pending",
            "testStrategy": "Test JSON output format matches expected structure, verify BigDecimal precision is preserved through serialization, test with various numeric types (Int32, Float64, BigDecimal), ensure type information is correctly included"
          },
          {
            "id": 3,
            "title": "Add YAML Serialization Support to Measurement Class",
            "description": "Implement YAML::Serializable module inclusion and ensure proper YAML serialization/deserialization",
            "dependencies": [
              "14.1"
            ],
            "details": "Update src/unit/measurement.cr to:\n- Include YAML::Serializable module\n- Add @[YAML::Field] annotations for value and unit fields\n- Use EnumConverter for unit field serialization in YAML\n- Ensure YAML output preserves BigDecimal precision\n- Handle both block and flow YAML styles\n- Implement from_yaml class method if needed for custom deserialization",
            "status": "pending",
            "testStrategy": "Test YAML round-trip serialization, verify different YAML styles work correctly, test precision preservation, ensure compatibility with standard YAML parsers"
          },
          {
            "id": 4,
            "title": "Implement Deserialization with Type Registry",
            "description": "Create a type registry system to enable deserialization of measurements back to their specific types (Weight, Length, etc.)",
            "dependencies": [
              "14.2",
              "14.3"
            ],
            "details": "Create src/unit/type_registry.cr with:\n- Registry mapping type names to measurement classes\n- Generic from_json and from_yaml methods that use type information\n- Automatic registration of measurement types (Weight, Length, Temperature, etc.)\n- Factory method to create correct measurement instance based on type field\n- Handle missing or invalid type information gracefully",
            "status": "pending",
            "testStrategy": "Test deserialization creates correct measurement types, verify unknown types raise appropriate errors, test registry with all implemented measurement types, ensure compile-time type safety is maintained"
          },
          {
            "id": 5,
            "title": "Create Comprehensive Serialization Tests",
            "description": "Develop a full test suite covering all serialization scenarios and edge cases",
            "dependencies": [
              "14.2",
              "14.3",
              "14.4"
            ],
            "details": "Create spec/unit/serialization_spec.cr with tests for:\n- Round-trip JSON serialization for all measurement types\n- Round-trip YAML serialization for all measurement types\n- Precision preservation with very large and very small BigDecimal values\n- Serialization of measurements created from different numeric types\n- Deserialization error handling (invalid JSON, missing fields, wrong types)\n- Performance benchmarks for large collections of measurements\n- Compatibility with Crystal's standard JSON/YAML libraries",
            "status": "pending",
            "testStrategy": "Use property-based testing for round-trip guarantees, test edge cases like infinity and NaN values, verify serialized format is human-readable, test interoperability with other Crystal JSON/YAML consumers"
          }
        ]
      },
      {
        "id": 15,
        "title": "Create Comprehensive Documentation and Examples",
        "description": "Write API documentation, guides, and example applications",
        "details": "Create comprehensive documentation:\n\n1. **README.md** with:\n   - Installation instructions\n   - Quick start examples\n   - Feature overview\n   - Links to detailed docs\n\n2. **API Documentation** using Crystal's doc generator:\n   - Document all public methods with examples\n   - Include type signatures and return values\n   - Add @[Deprecated] annotations where needed\n\n3. **Guide Documents**:\n   - `docs/getting-started.md` - Basic usage patterns\n   - `docs/lucky-integration.md` - Avram/Lucky setup guide\n   - `docs/custom-measurements.md` - Creating new measurement types\n   - `docs/performance.md` - Optimization tips and benchmarks\n\n4. **Example Applications**:\n   - `examples/basic_usage.cr` - Simple conversions and arithmetic\n   - `examples/lucky_app/` - Full Lucky app with product weights\n   - `examples/scientific.cr` - High-precision calculations\n   - `examples/cooking.cr` - Recipe conversions\n\n5. **Migration Guide**:\n   - Converting from manual calculations\n   - Upgrading from other libraries\n   - Common patterns and idioms\n\nUse crystal docs to generate HTML documentation and ensure all code examples compile and run correctly.",
        "testStrategy": "Verify all code examples compile and produce expected output, test documentation generation with 'crystal docs', ensure Lucky example app runs without errors, validate all links and references",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create README.md with Installation and Quick Start",
            "description": "Write the main README file with installation instructions, quick start examples, and feature overview",
            "dependencies": [],
            "details": "Create a comprehensive README.md following the Standard Readme specification. Include: clear installation instructions for adding the shard dependency, quick start code examples showing basic unit conversions, feature overview highlighting key capabilities like type safety and precision, badges for CI status and documentation, links to detailed documentation sections, and a table of contents for easy navigation.",
            "status": "pending",
            "testStrategy": "Verify all code examples in README compile and run correctly, ensure installation instructions work on fresh Crystal project, validate all internal and external links"
          },
          {
            "id": 2,
            "title": "Generate API Documentation with Crystal Docs",
            "description": "Document all public APIs using Crystal's documentation comments and generate HTML documentation",
            "dependencies": [],
            "details": "Add comprehensive documentation comments to all public classes, modules, and methods in the codebase. Include: method signatures with parameter types and return values, usage examples for each public method, @[Deprecated] annotations where applicable, module-level documentation explaining the purpose and usage patterns, macro documentation with expansion examples. Configure crystal docs generation with custom CSS if needed and ensure all examples in comments are valid Crystal code.",
            "status": "pending",
            "testStrategy": "Run crystal docs and verify HTML generation without errors, check all code examples in documentation comments compile, ensure cross-references between types work correctly"
          },
          {
            "id": 3,
            "title": "Write User Guide Documentation",
            "description": "Create comprehensive guide documents covering different usage patterns and integrations",
            "dependencies": [
              "15.1"
            ],
            "details": "Create four detailed guide documents: docs/getting-started.md covering basic usage patterns, unit conversion examples, and arithmetic operations; docs/lucky-integration.md explaining Avram model integration, form handling, and database storage patterns; docs/custom-measurements.md showing how to create new measurement types with proper unit enums and conversion factors; docs/performance.md with optimization tips, benchmark results, and best practices for high-precision calculations. Each guide should include runnable code examples and troubleshooting sections.",
            "status": "pending",
            "testStrategy": "Verify all code snippets in guides compile and produce expected output, test Lucky integration examples in a real Lucky app, ensure custom measurement examples work as documented"
          },
          {
            "id": 4,
            "title": "Develop Example Applications",
            "description": "Create complete example applications demonstrating various use cases",
            "dependencies": [
              "15.2",
              "15.3"
            ],
            "details": "Develop four example applications: examples/basic_usage.cr demonstrating simple conversions, arithmetic operations, and formatting; examples/lucky_app/ as a full Lucky application with products having weights, a shopping cart calculating total weights, and form handling for measurements; examples/scientific.cr showing high-precision calculations, custom precision settings, and scientific notation handling; examples/cooking.cr featuring recipe scaling, ingredient conversions between volume and weight, and temperature conversions. Each example should be self-contained and runnable.",
            "status": "pending",
            "testStrategy": "Ensure all example applications compile and run without errors, verify Lucky example app can be started and used, test that examples produce correct output for given inputs"
          },
          {
            "id": 5,
            "title": "Create Migration Guide and Best Practices",
            "description": "Write migration guide for adopting the library and document best practices",
            "dependencies": [
              "15.3",
              "15.4"
            ],
            "details": "Create docs/migration-guide.md covering: step-by-step instructions for converting from manual calculation approaches, migration from other measurement libraries with code comparison examples, common patterns and idioms for effective library usage, performance considerations when migrating existing codebases, database migration strategies for existing data. Include a troubleshooting section addressing common migration issues and a checklist for validating successful migration.",
            "status": "pending",
            "testStrategy": "Test migration examples by actually converting sample code, verify database migration strategies with different scenarios, ensure all migration patterns compile and work correctly"
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-08-01T04:58:51.369Z",
      "updated": "2025-08-01T07:05:06.583Z",
      "description": "Tasks for master context"
    }
  }
}