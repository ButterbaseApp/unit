# Task ID: 10
# Title: Implement String Formatting System
# Status: done
# Dependencies: 3, 4, 5
# Priority: medium
# Description: Create formatter for displaying measurements in various string formats
# Details:
Create src/unit/formatter.cr:
```crystal
module Unit
  module Formatter
    def to_s(io : IO) : Nil
      io << format
    end
    
    def format(precision : Int32 = 2, unit_format : Symbol = :short) : String
      formatted_value = format_value(precision)
      unit_string = format_unit(unit_format)
      "#{formatted_value} #{unit_string}"
    end
    
    def humanize : String
      value_str = @value == @value.to_i ? @value.to_i.to_s : @value.to_s("F")
      unit_name = @unit.to_s.underscore.gsub('_', ' ')
      plural = @value == 1 ? "" : "s"
      "#{value_str} #{unit_name}#{plural}"
    end
    
    private def format_value(precision : Int32) : String
      if @value == @value.to_i
        @value.to_i.to_s
      else
        @value.round(precision).to_s("F")
      end
    end
    
    private def format_unit(format : Symbol) : String
      case format
      when :short
        # Use enum name or alias
        @unit.to_s.downcase
      when :long
        @unit.to_s.underscore.gsub('_', ' ')
      else
        @unit.to_s
      end
    end
  end
end
```
- Support configurable decimal precision
- Provide humanized output with pluralization
- Smart formatting (no decimals for whole numbers)
- Multiple unit display formats

# Test Strategy:
Test various formatting options, verify pluralization rules, test precision handling, test edge cases (0, 1, negative values), verify io streaming

# Subtasks:
## 1. Create Formatter Module Structure [done]
### Dependencies: None
### Description: Set up the base Formatter module file and integrate it with the Measurement class
### Details:
Create src/unit/formatter.cr with the module structure and include it in the Measurement class. Ensure proper module nesting and namespace organization.

## 2. Implement Basic to_s and format Methods [done]
### Dependencies: 10.1
### Description: Implement the core formatting methods including to_s(io) and format with precision and unit format options
### Details:
Implement to_s(io : IO) for IO streaming support and format(precision, unit_format) method with configurable decimal precision and unit display formats (:short, :long). Handle whole number formatting without decimals.

## 3. Implement Humanize Method with Pluralization [done]
### Dependencies: 10.1
### Description: Create the humanize method with intelligent pluralization rules for user-friendly output
### Details:
Implement humanize method that converts unit names to human-readable format with proper pluralization. Handle edge cases like 1 (singular), 0 (plural), negative values, and fractional values. Convert enum names to readable format (e.g., Kilogram -> kilogram/kilograms).

## 4. Implement Private Helper Methods [done]
### Dependencies: 10.2
### Description: Create format_value and format_unit private helper methods for consistent formatting logic
### Details:
Implement format_value(precision) to handle BigDecimal formatting with configurable precision and smart whole number detection. Implement format_unit(format) to handle different unit display formats using enum methods like to_s, underscore transformations.

## 5. Add Unit-Specific Format Customization [done]
### Dependencies: 10.4
### Description: Extend formatter to support unit-specific formatting rules and aliases
### Details:
Add support for unit-specific formatting rules, such as using unit aliases when available (e.g., kg instead of kilogram in short format). Ensure the formatter can access unit enum aliases and handle them appropriately in different format modes.

